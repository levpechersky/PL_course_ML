val _ = print "----------------------------------------------\n";
val _ = print "    Testing. Everything should return true    \n";
val _ = print "----------------------------------------------\n";

val _ = print "\nTests from assignment:\n";
common ["PL", "PL", "is", "fun", "PL"] = "PL";
sequence[1,2,3,4,1,5,5] = [1,2,3,4];
thin [3,3,2,7,5,7,5] = [(3,2), (2,1), (7,2), (5, 2)];
are_nighbours((0,1,1,0), (1,0,0,0));
not (are_nighbours((0,0,1,0), (0,1,1,1)));
is_valid_maze [[(0,0,0,0), (0,0,0,0),(0,0,0,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)]];
is_valid_maze [[(0,1,1,0),(1,0,0,1),(0,0,1,0)],[(0,0,0,0),(0,1,1,0),(1,0,0,1)],[(0,0,0,0),(0,0,0,1),(0,1,0,0)]];
not (is_valid_maze [[(0,1,1,0),(0,1,0,0),(0,0,1,0)],[(0,0,0,0),(0,1,1,0),(1,0,0,1)],[(0,0,0,0),(0,0,0,1),(0,0,0,0)]]);
exit_maze [[(0,1,1,0),(1,0,0,1),(0,0,1,0)],[(0,0,0,0),(0,1,1,0),(1,0,0,1)],[(0,0,0,0),(0,0,0,1),(0,1,1,1)]];
not (exit_maze [[(0,1,1,0),(1,0,0,0),(0,0,0,0)],[(0,0,0,1),(0,0,0,1),(0,0,0,0)],[(0,1,0,0),(0,1,0,0),(0,0,0,0)]]);
one_path_maze[[(0,1,1,0), (1,0,1,0),(1,0,1,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)],[(0,0,0,0), (0,0,0,0),(0,0,0,0)]];
not (one_path_maze [[(0,1,1,0),(1,0,0,1),(0,0,1,0)],[(0,0,0,0),(0,1,1,1),(1,0,0,1)],[(0,0,0,0),(0,1,0,1),(0,1,1,1)]]);


val _ = print "\nTests of common:\n";
common ["forever alone"] = "forever alone";
common ["hodor","hodor","hodor","hodor","hodor","hodor","hodor"] = "hodor";
common [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5] = 5;


val _ = print "\nTests of sequence\n";
sequence [1,1,1,1,1,1,1] = [1];
sequence [1,3,4,6,7,8,10,11,12,13] = [10,11,12,13];
sequence [1,2,3,6,7,8] = [1,2,3]; (* ??? Not sure about this *)
sequence [] = [];


val _ = print "\nTests of thin:\n";
thin ["hodor","hodor","hodor","hodor","hodor","hodor","hodor"] = [("hodor", 7)];
thin [] = [];
thin [1] = [(1,1)];


val _ = print "\nTests of are_nighbours:\n";
(* Super-legal neighbors (for any direction) *)
(* Return true for each pair *)
are_nighbours((0,0,0,0), (0,0,0,0));
are_nighbours((0,0,0,1), (0,1,0,0));
are_nighbours((0,0,1,0), (1,0,0,0));
are_nighbours((0,0,1,1), (1,1,0,0));
are_nighbours((0,1,0,0), (0,0,0,1));
are_nighbours((0,1,0,1), (0,1,0,1));
are_nighbours((0,1,1,0), (1,0,0,1));
are_nighbours((0,1,1,1), (1,1,0,1));
are_nighbours((1,0,0,0), (0,0,1,0));
are_nighbours((1,0,0,1), (0,1,1,0));
are_nighbours((1,0,1,0), (1,0,1,0));
are_nighbours((1,0,1,1), (1,1,1,0));
are_nighbours((1,1,0,0), (0,0,1,1));
are_nighbours((1,1,0,1), (0,1,1,1));
are_nighbours((1,1,1,0), (1,0,1,1));
are_nighbours((1,1,1,1), (1,1,1,1));

(* Only illegal neighbors for any direction *)
(* Return false  for each pair *)
not (are_nighbours((0,0,0,0),(1,1,1,1)));
not (are_nighbours((0,0,0,1),(1,0,1,1)));
not (are_nighbours((0,0,1,0),(0,1,1,1)));
not (are_nighbours((0,0,1,1),(0,0,1,1)));
not (are_nighbours((0,1,0,0),(1,1,1,0)));
not (are_nighbours((0,1,0,1),(1,0,1,0)));
not (are_nighbours((0,1,1,0),(0,1,1,0)));
not (are_nighbours((0,1,1,1),(0,0,1,0)));
not (are_nighbours((1,0,0,0),(1,1,0,1)));
not (are_nighbours((1,0,0,1),(1,0,0,1)));
not (are_nighbours((1,0,1,0),(0,1,0,1)));
not (are_nighbours((1,0,1,1),(0,0,0,1)));
not (are_nighbours((1,1,0,0),(1,1,0,0)));
not (are_nighbours((1,1,0,1),(1,0,0,0)));
not (are_nighbours((1,1,1,0),(0,1,0,0)));
not (are_nighbours((1,1,1,1),(0,0,0,0)));

let
  (* All rooms. Room is 4 walls in order left top right bottom *)
  (* If wall is 1 - can pass that way, otherwise - can't *)
  val all_rooms = [(0,0,0,0),
  (0,0,0,1),
  (0,0,1,0),
  (0,0,1,1),
  (0,1,0,0),
  (0,1,0,1),
  (0,1,1,0),
  (0,1,1,1),
  (1,0,0,0),
  (1,0,0,1),
  (1,0,1,0),
  (1,0,1,1),
  (1,1,0,0),
  (1,1,0,1),
  (1,1,1,0),
  (1,1,1,1) ];

  (* Cross-product of 2 lists *)
  fun cartesian (_,[]) = []
   | cartesian ([],_) = []
   | cartesian (x::xs, ys) = (map (fn y => (x,y)) ys) @ (cartesian (xs,ys));

  val cross = cartesian(all_rooms, all_rooms);
in
  (* There's 256 possible pairs of rooms (with repetitions),
     and 16 among them are not neighbours in any order *)
  length(List.filter (fn x => are_nighbours x) cross) = 240
end;


val _ = print "\nTests of is_valid_maze:\n";
(* Valid mazes *)
is_valid_maze [[(0,0,0,0)]];
is_valid_maze [[(1,1,1,1)]];
is_valid_maze [[(0,1,1,0),(1,1,0,0)],[(1,0,0,1),(0,0,1,1)],[(0,1,1,1),(1,1,0,0)],[(0,1,0,0),(0,0,0,1)]]; (* 4x2 *)
is_valid_maze [[(0,1,1,0),(1,0,1,0),(1,1,0,0)],[(1,0,1,0),(1,0,1,1),(1,0,1,0)]]; (* 2x3 *)
is_valid_maze [[(0,1,1,0),(1,1,0,0)],[(1,0,0,1),(0,0,1,1)]]; (* 4x1 *)
is_valid_maze [[(0,1,1,0),(1,0,1,0),(1,1,0,0)]]; (* 1x3 *)

(* Invalid mazes *)
not (is_valid_maze [[(0,1,1,0),(1,1,0,0)],[(1,0,0,1),(1,1,0,0)],[(0,1,1,1),(1,1,0,0)],[(0,1,0,0),(0,0,0,1)]]); (* 4x2 *)
not (is_valid_maze [[(0,1,1,0),(1,0,1,0),(1,1,0,0)],[(1,0,1,0),(1,0,1,1),(0,1,0,1)]]); (* 2x3 *)
not (is_valid_maze [[(0,1,1,0)],[(1,0,0,0)],[(1,0,0,1)],[(0,0,0,1)]]); (* 4x1 *)
not (is_valid_maze [[(0,1,0,0),(1,1,1,0),(0,1,0,0)]]); (* 1x3 *)


val _ = print "\nTests of exit_maze:\n";
(* Mazes with exit *)
exit_maze [[(1,1,1,1)]];
(* All corners are 1-room in and out paths *)
exit_maze [[(1,1,0,0),(0,0,0,0),(0,1,1,0)],
    		   [(0,0,0,0),(0,0,0,0),(0,0,0,0)],
    		   [(1,0,0,1),(0,0,0,0),(0,0,1,1)]];

(* Snake like through all rooms *)
exit_maze [[(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)]];

val _ = print "Wait for it... This may take a while.\n";
(* This one may take too long. I have never got this to end. *)
(*
exit_maze [[(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)]];
*)

(* Simpler case. Took about 5 sec without optimization *)
exit_maze [[(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)],
    		   [(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1)]];

(* Mazes with no exit *)
not (exit_maze [[(0,0,0,0)]]);

(* Snake-like path through all rooms *)
not (exit_maze [[(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,1),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)],
    		   [(0,1,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,0,1)],
    		   [(0,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,1,0,0)]]);
(*                 ^ this zero ruins it *)

not (exit_maze [[(0,1,0,1),(0,0,0,1),(0,1,0,1),(0,0,0,1)],
        	 	    [(0,1,0,1),(0,1,0,1),(0,1,0,1),(0,1,0,1)],
        	 	    [(0,1,0,0),(0,1,0,1),(0,1,0,0),(0,1,0,1)]]);

(* Same invalid mazes from valid_maze. Hence, exit_maze returns false *)
not (exit_maze [[(0,1,1,0),(1,1,0,0)],[(1,0,0,1),(1,1,0,0)],[(0,1,1,1),(1,1,0,0)],[(0,1,0,0),(0,0,0,1)]]); (* 4x2 *)
not (exit_maze [[(0,1,1,0),(1,0,1,0),(1,1,0,0)],[(1,0,1,0),(1,0,1,1),(0,1,0,1)]]); (* 2x3 *)
not (exit_maze [[(0,1,1,0)],[(1,0,0,0)],[(1,0,0,1)],[(0,0,0,1)]]); (* 4x1 *)
not (exit_maze [[(0,1,0,0),(1,1,1,0),(0,1,0,0)]]); (* 1x3 *)


val _ = print "\nTests of one_path_maze:\n";
(* According to Rana paths are distinct, if they are different by at least one room. *)
(* Same invalid mazes from valid_maze. Hence, one_path_maze returns false *)
not (one_path_maze [[(0,1,1,0),(1,1,0,0)],[(1,0,0,1),(1,1,0,0)],[(0,1,1,1),(1,1,0,0)],[(0,1,0,0),(0,0,0,1)]]); (* 4x2 *)
not (one_path_maze [[(0,1,1,0),(1,0,1,0),(1,1,0,0)],[(1,0,1,0),(1,0,1,1),(0,1,0,1)]]); (* 2x3 *)
not (one_path_maze [[(0,1,1,0)],[(1,0,0,0)],[(1,0,0,1)],[(0,0,0,1)]]); (* 4x1 *)
not (one_path_maze [[(0,1,0,0),(1,1,1,0),(0,1,0,0)]]); (* 1x3 *)

one_path_maze [[(1,0,1,0)]]; (* ??? Not sure about that *)
one_path_maze [[(1,1,1,1)]]; (* ??? Not sure about that *)

one_path_maze [[(1,0,1,0),(1,0,1,0),(1,0,1,0),(1,0,1,0)]]; (* 1x4 *)

one_path_maze [[(0,1,1,0),(1,0,0,1),(0,1,1,0),(1,0,1,0),(1,0,0,0)],
        	 	   [(0,0,1,1),(1,1,1,1),(1,0,1,0),(1,0,1,0),(1,0,0,0)],
        	 	   [(0,1,0,1),(0,1,0,1),(0,0,0,0),(0,0,1,1),(1,0,0,1)],
        	 	   [(0,1,0,0),(0,1,1,0),(1,0,1,0),(1,1,0,0),(0,1,0,1)]];

(* No pass => not one path *)
not (one_path_maze [[(0,0,0,0)]]);
not (one_path_maze [[(0,0,0,0),(0,0,0,0),(0,0,0,0)],
             		    [(0,0,0,0),(0,0,0,0),(0,0,0,0)],
             		    [(0,0,0,0),(0,0,0,0),(0,0,0,0)],
            		    [(0,0,0,0),(0,0,0,0),(0,0,0,0)]]);

(* 2 distinct paths between two exits *)
not (one_path_maze [[(0,1,1,1),(1,0,0,1)],[(0,1,1,0),(1,1,0,1)]]);
(* At each angle there's 1-room path *)
not (one_path_maze [[(1,1,0,0),(0,1,1,0)],[(1,0,0,1),(0,0,1,1)]]);
(* Few exits at start/finish. Hence, there's regular path, crossing all rooms,
and one or more 1-room paths *)
not (one_path_maze [[(1,1,1,1),(1,0,1,0),(1,0,1,0),(1,1,1,1)]]); (* 1x4 *)

not (one_path_maze [[(1,1,1,1),(1,1,1,1),(1,1,1,1)],
             		    [(1,1,1,1),(1,1,1,1),(1,1,1,1)],
             		    [(1,1,1,1),(1,1,1,1),(1,1,1,1)],
            		    [(1,1,1,1),(1,1,1,1),(1,1,1,1)]]);
